
// Sinusoidal Transition Functions
// arg1 : TIME POINT  | The current point in time along the confines of the wavelength
// arg2 : WAVELENGTH  | Measured in millis by which a full cycle will have been completed
// arg3 : DOUBLERANGE | When set to true, the wave will flip around upon reaching 0, going to the negative but continuing the same pattern.
//                    > This is designed to give equal fade times both to 0 and non-0 colors. You can have a triple gradient this way too.
coswave = [
	if $arg2 [
		local x y 
		x = (modf (*f 180 (divf $arg1 $arg2)) 720)
		y = (+f 0.5 (*f 0.5 (cos $x)))
		if (&& $arg3 [>= $x 180] [< $x 540]) [ y = (*f $y -1) ]
		result $y
	] [ result 1 ]
]
sinwave = [
	if $arg2 [
		local x y 
		x = (modf (*f 180 (divf $arg1 $arg2)) 720)
		y = (+f 0.5 (*f 0.5 (sin $x)))
		if (&& $arg3 [>= $x 180] [< $x 540]) [ y = (*f $y -1) ]
		result $y
	] [ result 1 ]
]

// coswave.INT  INT:1  INT:2  rep-millis  custom-X  DOUBLERANGE
// NOT giving more than 3 parameters will have the script assume it's working within a UImenu.
coswave.INT = [
	if (>= $numargs 4) [
		arg4 = (coswave (- $getmillis $arg4) $arg3 $arg5)
	] [ arg4 = (UIcoswave $arg3) ]

	local r1 g1 b1 r2 g2 b2
	INT_to_RGB32 $arg1 [ r1 = $r ; g1 = $g ; b1 = $b ]
	INT_to_RGB32 $arg2 [ r2 = $r ; g2 = $g ; b2 = $b ]

	RGB32_to_INT 255 (
		round (+f $r2 (*f (- $r2 $r1) -1 $arg4))
	) (
		round (+f $g2 (*f (- $g2 $g1) -1 $arg4))
	) (
		round (+f $b2 (*f (- $b2 $b1) -1 $arg4))
	)
]

// coswave.RGB24  R:1 B:1 G:1  R:2 G:2 B:2  rep-millis  custom-X  DOUBLERANGE
// NOT giving more than 7 parameters will have the script assume it's working within a UImenu.
coswave.RGB24 = [
	if (>= $numargs 8) [
		arg8 = (coswave (- $getmillis $arg8) $arg7 $arg9)
	] [ arg8 = (UIcoswave $arg7) ]

	RGB32_to_INT 255 (
		round (+f $arg4 (*f (- $arg4 $arg1) -1 $arg8))
	) (
		round (+f $arg5 (*f (- $arg5 $arg2) -1 $arg8))
	) (
		round (+f $arg6 (*f (- $arg6 $arg3) -1 $arg8))
	)
]

// cos/sinwave.bounce X millis offset
// meant to limit the wave return value to a particular X range, with 0 being the middle
coswave.bounce = [ -f (*f $arg1 (coswave (+ $getmillis $arg3) $arg2)) (divf $arg1 2) ]
sinwave.bounce = [ -f (*f $arg1 (sinwave (+ $getmillis $arg3) $arg2)) (divf $arg1 2) ]


// vdirdelta DIR ACTION X Y 
// vdirdelta N offset 8 0
vdirdelta = [
	if (> $getselface 3) [
		if (=f $arg3 0.0) [ arg3 = $arg4 ]
		arg3 = (absf $arg3)
		local transform_dir camyaw

		// transform_dir ACTION VALUE {X Y}COORDINATE_MULTIPLIERS_PER_DIR_x4
		transform_dir = [
			camyaw = (modf (+f $getcamyaw 45) 360)
			cond [< $camyaw 90] [
				$arg1 (*f $arg2 $arg3) (*f $arg2 $arg4)
			] [< $camyaw 180] [
				$arg1 (*f $arg2 $arg5) (*f $arg2 $arg6)
			] [< $camyaw 270] [
				$arg1 (*f $arg2 $arg7) (*f $arg2 $arg8)
			] [ $arg1 (*f $arg2 $arg9) (*f $arg2 $arg10) ]
		]

		vdelta [
			cases $arg1 "N" [ // camera dir:  N       E       S       W
				transform_dir $arg2 $arg3    0 -1    1  0    0  1    1  0
			] "E" [
				transform_dir $arg2 $arg3    1  0    0  1    1  0    0 -1
			] "S" [
				transform_dir $arg2 $arg3    0  1   -1  0    0 -1   -1  0
			] "W" [
				transform_dir $arg2 $arg3   -1  0    0 -1   -1  0    0  1
			] () [ error "'arg1' must be a cardinal direction character."]
		]
	] [ vdelta [ $arg2 $arg3 $arg4 ] ]
]

UImenu "coswave_test" [
	uigrid 2 $.UI_pad_L $.UI_pad_L [
		UIhsliderslim wavelength 200 10000 200 0.25 $.UI_pad_6XL
		uispace $.UI_pad_L 0 [
			uialign -1 0
			uiclampx
			uihlist 0 [
				uiclampx
				uitext (UIcoswave $wavelength) 0.6
				uitext (concatword (+ (round (*f 100 (UIcoswave $wavelength))) 0) "%") 0.8
			]
		]

		uicolor (coswave.RGB24 255 10 20 120 100 230 $wavelength) 0.25 0.5 [
			uivlist 0 [
				uialign 0 1
				uiline 0xFFFFFF 0.25
				uifill 0 (*f (UIcoswave $wavelength) 0.5)
			]
		]
		uicolor (coswave.INT 0x7864E6 0xFF0A14 $wavelength) 0.25 0.5 [
			uivlist 0 [
				uialign 0 1
				uiline 0xFFFFFF 0.25
				uifill 0 (*f (UIcoswave $wavelength) 0.5)
			]
		]
	]
] [ wavelength = 2000 ]
