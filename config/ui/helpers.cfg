
// Sinusoidal Transition Function
// arg1 : TIME POINT  | The current point in time along the confines of the wavelength
// arg2 : WAVELENGTH  | Measured in millis by which a full cycle will have been completed
// arg3 : 0-INVERTION | When set to true, the wave will flip around upon reaching 0, going to the negative but continuing the same pattern.
//                    > This is designed to give equal fade times both to 0 and non-zero colors. You can have a triple gradient this way too.


coswave = [
	local x y 
	x = (modf (*f 180 (divf $arg1 $arg2)) 720)
	y = (+f 0.5 (*f 0.5 (cos $x)))
	if (&& $arg3 [>= $x 180] [< $x 540]) [ y = (*f $y -1) ]
	result $y
]

coswave2color = [
	local r1 g1 b1 r2 g2 b2 dr
	INT_to_RGB32 $arg1 [ r1 = $r ; g1 = $g ; b1 = $b ]
	INT_to_RGB32 $arg2 [ r2 = $r ; g2 = $g ; b2 = $b ]
	RGB32_to_INT 255 (
		+f $r2 (*f (-f $r2 $r1) -1 (coswave (- $getmillis $origin) $arg3))
	) (
		+f $g2 (*f (-f $g2 $g1) -1 (coswave (- $getmillis $origin) $arg3))
	) (
		+f $b2 (*f (-f $b2 $b1) -1 (coswave (- $getmillis $origin) $arg3))
	)
]


UImenu "coswave" [
	uivlist 0.02 [
		uihlist 0 [
			uiclamp 1 1
			uitext (coswave (- $getmillis $origin) $wavelength) 0.8
			UIhsliderslim wavelength 200 10000 0.25 0.04 [ origin = $getmillis ]
		]

		uicolor (coswave2color -62956 -8887066 $wavelength) 0.5 0.5 [
			uivlist 0 [
				uialign 0 1
				uiline 0xFFFFFF 0.5
				uifill 0 (*f (coswave (- $getmillis $origin) $wavelength) 0.5)
			]
		]
	]
] [
	origin = $getmillis
	wavelength = 2000
	// color1 = [255  10  20]
	// color2 = [120 100 230]
]

// showui "test"